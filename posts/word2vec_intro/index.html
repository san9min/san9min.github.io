<!DOCTYPE html>
<html lang="ko"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Sangmin Blog | Word to Vector</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
  
  <link rel="stylesheet"
     href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<link rel="stylesheet" href="../../assets/styles/main.css">
  
<link rel="icon" type="image/png" href="/assets/favicon.png" sizes="32x32">
</head><body>
  <main class="article">
    <h1>Word to Vector</h1>
    <div class="meta">Jul 18, 2022 · 15 min read</div>
    <img class="hero" src="../..//images/word2vec_intro/thumbnail.png" alt="cover image">
    <h3>🤖 GPT-3와 단어의 의미</h3>
<p>GPT 같은 언어 모델은 말 그대로 AGI로 가는 첫걸음이다.<br>그 시작은 아주 단순한 질문에서 출발한다.</p>
<blockquote>
<p><strong>&quot;단어의 의미를 컴퓨터가 어떻게 알 수 있을까?&quot;</strong></p>
</blockquote>
<p>사전적으로 의미는 이런 것들이다:</p>
<ul>
<li>단어나 문장이 표현하는 개념</li>
<li>사람이 단어를 통해 전하려는 생각</li>
<li>글이나 예술작품 안에서 드러나는 메시지</li>
</ul>
<p>언어학에서는 보통 <code>기호(signifier)</code>와 <code>지시 대상(signified)</code>의 관계로 설명한다.  </p>
<p>이건 **지시적 의미론(denotational semantics)**이라고 부른다.</p>
<hr>
<h3>💻 의미를 컴퓨터에 어떻게 표현할까?</h3>
<p>초기 자연어처리(NLP)에서는 WordNet 같은 자원을 사용했다.<br>WordNet은 유의어나 상위어 관계를 정리한 대형 사전이다.</p>
<p>하지만 이런 자원에는 여러 한계가 있다:</p>
<ul>
<li>의미의 <strong>미묘한 차이</strong>를 반영하지 못한다<br><em>(예: “proficient”는 항상 “good”과 같지 않다)</em></li>
<li>새로운 단어나 <strong>은어(slang)</strong> 를 반영하기 어렵다<br><em>(예: wicked, ninja, bombest 등)</em></li>
<li>사람이 계속 업데이트해야 하므로 <strong>효율이 낮고 주관적이다</strong></li>
<li><strong>단어 간 유사도</strong>를 수치로 계산하기 어렵다</li>
</ul>
<hr>
<h3>🧾 기존 방식: 단어를 기호로 표현하기</h3>
<p>과거 NLP에서는 단어를 <strong>고유한 기호</strong>로 다뤘다.<br>예: <code>hotel</code>, <code>conference</code>, <code>model</code></p>
<p>이 방식에서는 단어를 <strong>one-hot vector</strong>로 표현한다:</p>
<ul>
<li><code>motel = [0 0 0 0 0 0 0 0 0 0 1 0 0 0 0]</code></li>
<li><code>hotel = [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0]</code></li>
</ul>
<h4>문제 1</h4>
<p>벡터의 차원이 <strong>어휘 수만큼</strong> 커지고,<br>단어 간 관계나 유사성을 전혀 알 수 없다.</p>
<p>예를 들어, 사용자가 &quot;Seattle motel&quot;을 검색했을 때<br>&quot;Seattle hotel&quot; 관련 문서를 보여주고 싶어도<br>두 단어의 벡터가 **서로 직교(orthogonal)**하기 때문에<br>관련 문서를 찾기 어렵다.</p>
<h4>문제 2</h4>
<p>one-hot vector는 <strong>자연스러운 유사도 개념이 없다.</strong></p>
<hr>
<h3>📍 해결책: 문맥으로 단어를 표현하기</h3>
<h4>분포 의미론 (Distributional Semantics)</h4>
<blockquote>
<p>“You shall know a word by the company it keeps.”<br>— 단어는 주변 단어들을 통해 의미를 갖는다</p>
</blockquote>
<p>즉, 어떤 단어가 자주 함께 등장하는 **문맥(context)**을 보면<br>그 단어의 의미를 파악할 수 있다.</p>
<p>예를 들어 <code>banking</code>이라는 단어가 들어간 문장은 다음과 같다:</p>
<ul>
<li>&quot;... government debt problems turning into <code>banking</code> crises ...&quot;</li>
<li>&quot;... unified <code>banking</code> regulation ...&quot;</li>
<li>&quot;... India gave its <code>banking</code> system a boost ...&quot;</li>
</ul>
<p>이 주변 단어들이 <code>banking</code>의 의미를 구성하는 정보가 된다.</p>
<h3>🧱 Word Vectors: 단어를 벡터로 표현하기</h3>
<p>이제 단어를 실수(real number)로 이루어진 **밀집 벡터(dense vector)**로 표현한다.<br>이를 <strong>워드 임베딩(word embedding)</strong> 또는 **신경망 단어 표현(neural word representation)**이라고 한다.</p>
<p>같은 문맥에서 자주 등장하는 단어들은 <strong>비슷한 벡터</strong>를 갖도록 훈련된다.</p>
<p>예:</p>
<pre><code>banking = [0.286, 0.792, -0.177, ..., 0.271]
</code></pre>
<h3>⚙️ Word2Vec: 벡터를 학습하는 알고리즘</h3>
<p><strong>Word2Vec</strong>은 대규모 텍스트로부터 단어 벡터를 학습하는 알고리즘이다.</p>
<h4>핵심 아이디어</h4>
<ul>
<li>텍스트 전체를 훑으면서, 각 위치마다 중심 단어(center word)와 주변 단어(context word)를 찾는다.</li>
<li>중심 단어가 주어졌을 때, 주변 단어가 나올 <strong>확률</strong>을 계산한다.</li>
<li>이 확률이 높아지도록 벡터들을 계속 업데이트한다.</li>
</ul>
<h3>🎯 목표 함수(Objective Function)</h3>
<p>Word2Vec의 학습 목표는<br><strong>주어진 중심 단어로 주변 단어들을 잘 예측할 수 있도록</strong> 벡터를 조정하는 것이다.</p>
<p>목표 함수는 다음과 같다:</p>
<p>$$
J(\theta) = - \frac{1}{T} \sum_{t=1}^T \sum_{-m \le j \le m, j \ne 0} \log P(w_{t+j} | w_t; \theta)
$$</p>
<h3>📈 확률 계산 방법</h3>
<p>확률은 소프트맥스(softmax)를 사용해 계산한다:</p>
<p>$$
P(o|c) = \frac{e^{u_o^T v_c}}{\sum_{w \in V} e^{u_w^T v_c}}
$$</p>
<ul>
<li>$v_c$: 중심 단어의 벡터</li>
<li>$u_o$: 주변 단어의 벡터</li>
</ul>
<h3>🔧 벡터 업데이트: 관측값 vs 기대값</h3>
<p>목표 함수를 중심 단어 벡터 $v_c$로 미분하면</p>
<p>$$
\frac{\partial \log P(o|c)}{\partial v_c} = u_o - \sum_{x \in V} P(x|c) u_x
$$</p>
<ul>
<li>첫 번째 항: 실제로 관측된 주변 단어의 벡터</li>
<li>두 번째 항: 모델이 기대하는 주변 단어 벡터들의 평균</li>
</ul>
<p><strong>두 값이 비슷해지도록 벡터를 업데이트</strong>하는 것이 Word2Vec의 핵심이다.</p>
<aside>
단어 간 유사도를 벡터 내적이나 cosine similiarity로 계산할 수 있고
의미를 벡터 공간 위의 방향과 거리로 표현할 수 있다
</aside>


    <section class="related">
        <div class="related-head">
          <h2>Related posts</h2>
          <a class="all-link" href="../../">Browse all articles&nbsp;→</a>
        </div>
        <div class="related-list">
      <a class="card mini" href="../../posts/difussion_latent_diffusion/">
        <img class="thumb" src="../..//images/difussion_latent_diffusion/thumbnail.png" alt="">
        <div class="card-body">
        
          <h3 class="card-title">Difussion : Latent Diffusion</h3>
          <span class="arrow">↗</span>
          <div class="meta">Feb 7, 2023 · 20 min</div>
        </div>
      </a>
      <a class="card mini" href="../../posts/Diffusion_DDIM/">
        <img class="thumb" src="../../images/diffusion_ddim/thumbnail.png" alt="">
        <div class="card-body">
        
          <h3 class="card-title">Diffusion : DDIM</h3>
          <span class="arrow">↗</span>
          <div class="meta">Jan 31, 2023 · 20 min</div>
        </div>
      </a>
      <a class="card mini" href="../../posts/Diffusion_DDPM/">
        <img class="thumb" src="../..//images/diffusion_ddpm/thumbnail.jpg" alt="">
        <div class="card-body">
        
          <h3 class="card-title">Diffusion : DDPM</h3>
          <span class="arrow">↗</span>
          <div class="meta">Jan 22, 2023 · 20 min</div>
        </div>
      </a></div>
      </section> 
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
<script>
window.MathJax = {
  tex: {
    inlineMath:  [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    processEnvironments: true
  },

  chtml: {
    linebreaks: { automatic: true, width: "match" }  // 또는 width: 80
  },

  options: {
    renderActions: { addMenu: [] }   // 우클릭 메뉴 제거
  }
};
</script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <script src="../../assets/js/main.js" defer></script>
</body></html>